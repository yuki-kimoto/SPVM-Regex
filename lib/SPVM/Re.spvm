# Copyright (c) 2025 Yuki Kimoto
# MIT License

class Re {
  version_from Regex;
  
  use Regex;
  use Regex::Match;
  use Sync::Mutex;
  
  # Fields
  our $MUTEX : Sync::Mutex;
  
  our $REGEXES_H : Hash of Regex;
  
  INIT {
    $MUTEX = Sync::Mutex->new;
    
    $REGEXES_H = Hash->new;
  }
  
  static method m : Regex::Match ($string_or_buffer : object of string|StringBuffer, $pattern : string, $flags : string = undef, $offset_ref : int* = undef, $length : int = -1, $options : object[] = undef) {
    
    unless ($pattern) {
      die "The regex pattern $pattern must be defined.";
    }
    
    unless ($flags) {
      $flags = "";
    }
    
    my $has_g = 0;
    
    my $flags_without_g = (string)undef;
    if (Fn->contains($flags, "g")) {
      $has_g = 1;
      
      my $flags_length = length $flags;
      my $flags_without_g_tmp = (mutable string)new_string_len $flags_length;
      my $char_offset = 0;
      for (my $i = 0; $i < $flags_length; $i++) {
        my $char = $flags->[$i];
        unless ($char == 'g') {
          $flags_without_g_tmp->[$char_offset] = $char;
          $char_offset++;
        }
      }
      
      Fn->shorten_null_char($flags_without_g_tmp);
      $flags_without_g = $flags_without_g_tmp;
    }
    else {
      $flags_without_g = $flags;
    }
    
    $options = Fn->merge_options($options, {global => 1});
    
    my $regex_key = "(?$flags_without_g)$pattern";
    
    my $regex = (Regex)undef;
    
    {
      Fn->defer(method : void () {
         $MUTEX->reader_unlock;
      });
      
      $MUTEX->reader_lock;
      
      $regex = (Regex)$REGEXES_H->get($regex_key);
    }
    
    unless ($regex) {
      Fn->defer(method : void () {
         $MUTEX->unlock;
      });
      
      $MUTEX->lock;
      
      $regex = Regex->new($pattern, $flags_without_g);
      $REGEXES_H->set($regex_key, $regex);
    }
    
    my $match = $regex->match_v2($string_or_buffer, $offset_ref, $length);
    
    return $match;
  }
  
}
